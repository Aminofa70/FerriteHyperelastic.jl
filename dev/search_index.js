var documenterSearchIndex = {"docs":
[{"location":"functions/#Functions","page":"Functions","title":"Functions","text":"Functions for the package are listed as follows.\n\n","category":"section"},{"location":"functions/#FerriteHyperelastic.InputStruct","page":"Functions","title":"FerriteHyperelastic.InputStruct","text":" input = InputStruct()\n\nCreate a dynamic structure for FEM parameters\n\n\n\n\n\n","category":"type"},{"location":"functions/#FerriteHyperelastic.assemble_cell_3D!-Tuple{Any, Vector, Any, Any, InputStruct, Any}","page":"Functions","title":"FerriteHyperelastic.assemble_cell_3D!","text":"    assemble_cell_3D!( ke_n, fe_int::Vector, cell, cv, input::InputStruct, ue)\n\nThis function assembles local internal force and tangent stiffness for 3D\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_cell_plane_strain!-Tuple{Any, Vector, Any, Any, InputStruct, Any}","page":"Functions","title":"FerriteHyperelastic.assemble_cell_plane_strain!","text":"   assemble_cell_plane_strain!( ke_n, fe_int, cell, cv, input, ue)\n\nThis function assembles local internal force and tangent stiffness for plane strain\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_cell_plane_stress!-Tuple{Any, Vector, Any, Any, InputStruct, Any}","page":"Functions","title":"FerriteHyperelastic.assemble_cell_plane_stress!","text":"   assemble_cell_plane_stress!(ke_n, fe_int, cell, cv, input, ue)\n\nThis function assembles local internal force and tangent stiffness for plane stress\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_global_3D!-Tuple{Any, Any, Any, Any, InputStruct, Any}","page":"Functions","title":"FerriteHyperelastic.assemble_global_3D!","text":"  assemble_global_3D!(K_nonlinear, F_int, dh, cv, input, u)\n\nThis function assembles global internal force and tangent stiffness for 3D\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_global_plane_strain!-Tuple{Any, Any, Any, Any, InputStruct, Any}","page":"Functions","title":"FerriteHyperelastic.assemble_global_plane_strain!","text":"   assemble_global_plane_strain!(K_nonlinear, F_int, dh, cv, input, u)\n\nThis function assembles global internal force and tangent stiffness for plane strain\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_global_plane_stress!-Tuple{Any, Any, Any, Any, InputStruct, Any}","page":"Functions","title":"FerriteHyperelastic.assemble_global_plane_stress!","text":"   assemble_global_plane_stress!(K_nonlinear, F_int, dh, cv, input, u)\n\nThis function assembles global internal force and tangent stiffness for plane stress\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_traction_forces_threeD!-Tuple{Any, Ferrite.DofHandler{3, G} where G<:Ferrite.AbstractGrid{3}, Vector, Ferrite.FacetValues, Dict{Int64, <:AbstractVector}, AbstractVector}","page":"Functions","title":"FerriteHyperelastic.assemble_traction_forces_threeD!","text":"assemble_traction_forces_threeD!(F_ext, dh::DofHandler{3},facetsets::Vector, \nfacetvalues::FacetValues, tractions::Dict{Int, <:AbstractVector}, u::AbstractVector)\n\nThis function assembles the external force from traction for 3D\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.assemble_traction_forces_twoD!-Tuple{Any, Any, Vector, Any, Dict{Int64, <:AbstractVector}, AbstractVector}","page":"Functions","title":"FerriteHyperelastic.assemble_traction_forces_twoD!","text":"assemble_traction_forces_twoD!(F_ext, dh,  facetsets::Vector,  facetvalues,  \ntractions::Dict{Int, <:AbstractVector}, u::AbstractVector)\n\nThis function assembles the external force from traction for 2D plane stress and plane strain\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.initialize_solver","page":"Functions","title":"FerriteHyperelastic.initialize_solver","text":"initialize_solver([maxIterPerInc=500], [totalTime=1.0], [initInc=0.1],\n                  [minInc=1e-5], [maxInc=0.2], [totalInc=500])\n\nInitialize solver parameters for a time integration procedure.\n\n\n\n\n\n","category":"function"},{"location":"functions/#FerriteHyperelastic.run_fem-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_fem","text":"run_fem(input)\n\nthe general fem runner for all cases 2D & 3D \n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.run_plane_strain-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_plane_strain","text":"run_plane_strain(input)\n\nrun finite element for 2D plane strain\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.run_plane_strain_disp-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_plane_strain_disp","text":" run_plane_strain_disp(input)\n\nrun finite element for plane stain with displacement load\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.run_plane_stress-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_plane_stress","text":"run_plane_stress(input)\n\nrun finite element for plane stress\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.run_plane_stress_disp-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_plane_stress_disp","text":"run_plane_stress_disp(input)\n\nrun finite element for plane stress with displacement load \n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.run_threeD-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_threeD","text":"run_threeD(input)\n\nrun finite element for 3D \n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.run_threeD_disp-Tuple{InputStruct}","page":"Functions","title":"FerriteHyperelastic.run_threeD_disp","text":"run_threeD_disp(input)\n\nrun finite element code for 3D with displacement load\n\n\n\n\n\n","category":"method"},{"location":"functions/#FerriteHyperelastic.solve_lambda3-Tuple{Any, InputStruct}","page":"Functions","title":"FerriteHyperelastic.solve_lambda3","text":"solve_lambda3(F2d, input; tol=1e-10, maxit=25)\n\nThis functions finds F33 in plane stress \n\n\n\n\n\n","category":"method"},{"location":"tutorials/tutorial_fem/#Guid-to-use-Finite-Element-(fem)","page":"tutorial fem","title":"Guid to use Finite Element (fem)","text":"","category":"section"},{"location":"tutorials/tutorial_fem/#Create-Input-Data-Structure","page":"tutorial fem","title":"Create Input Data Structure","text":"Create a dynamic structure for putting FEM parameters into it.\n\ninput = InputStruct()\n\ntipo: Tipo\nDefine geometry, mesh, and FEM parameters for interpolation and numerical integration, and define degree-of-freedom using Ferrite.jl.More details for these parts can be found in Ferrite.jl.","category":"section"},{"location":"tutorials/tutorial_fem/#Mesh-generation","page":"tutorial fem","title":"Mesh generation","text":"Generate mesh \n\n\"\"\"\nLx : Lenght in x-direction\nLy : Lenght in y-direction\nFerrite.Quadrilateral: Define the type of elements.\nnx : Number of element in x-dir \nny : Number of element in y-dir\n\"\"\"\nfunction create_grid(Lx, Ly, nx, ny)\n    corners = [\n        Ferrite.Vec{2}((0.0, 0.0)), Ferrite.Vec{2}((Lx, 0.0)),\n        Ferrite.Vec{2}((Lx, Ly)), Ferrite.Vec{2}((0.0, Ly))\n    ]\n    grid = Ferrite.generate_grid(Ferrite.Quadrilateral, (nx, ny), corners)\n    addnodeset!(grid, \"support_1\", x -> x[1] ≈ 0.0)\n    addfacetset!(grid, \"pressure\", x -> x[1] ≈ Lx)\n    return grid\nend\n","category":"section"},{"location":"tutorials/tutorial_fem/#Define-FEM-values","page":"tutorial fem","title":"Define FEM values","text":"Define FEM values (interpolation and numerical integration)\n\nfunction create_values()\n    dim, order = 2, 1\n    ip = Ferrite.Lagrange{Ferrite.RefQuadrilateral,order}()^dim\n    qr = Ferrite.QuadratureRule{Ferrite.RefQuadrilateral}(2)\n    qr_face = Ferrite.FacetQuadratureRule{Ferrite.RefQuadrilateral}(2)\n    return Ferrite.CellValues(qr, ip), Ferrite.FacetValues(qr_face, ip)\nend\n\n\nnote: Note\nVery important to know is that the type here should be the same as the element type.","category":"section"},{"location":"tutorials/tutorial_fem/#Define-DOF","page":"tutorial fem","title":"Define DOF","text":"Define dof (degree of freedom)\n\nfunction create_dofhandler(grid)\n    dh = Ferrite.DofHandler(grid)\n    Ferrite.add!(dh, :u, Ferrite.Lagrange{Ferrite.RefQuadrilateral,1}()^2)\n    Ferrite.close!(dh)\n    return dh\nend\n","category":"section"},{"location":"tutorials/tutorial_fem/#Dirichlet-Boundary-Condition","page":"tutorial fem","title":"Dirichlet Boundary Condition","text":"Define Dirichlet Boundary Condition\n\nfunction create_bc(dh)\n    ch = Ferrite.ConstraintHandler(dh)\n    Ferrite.add!(ch, Ferrite.Dirichlet(:u, Ferrite.getnodeset(dh.grid, \"support_1\"), (x, t) -> [0.0, 0.0], [1, 2]))\n    Ferrite.close!(ch)\n    return ch\nend\n\n\nhint: Hint\nOptional step: if users need to plot a force-displacement curve, getting the degree of freedom from reaction force and displacement is required. For the displacement, the Dirichlet boundary condition is used. For the force, another boundary condition is defined. If this plot is not the aim, it is not necessary to define the following code. \n\nfunction create_bc_force(dh)\n    dbc = Ferrite.ConstraintHandler(dh)\n    Ferrite.add!(dbc, Ferrite.Dirichlet(:u, getfacetset(grid, \"pressure\"), (x, t) -> 0*x))\n    Ferrite.close!(dbc)\n    return dbc\nend\n\n\nimportant: Important\nIt seems that Ferrite.jl does not have a direct way for finding the degree of freedom. For this reason, the above code is defined to find the degree of freedom of the reaction force, as will be seen in the following.\n\nTo now, the required functions for FEM were defined.\n\nThese parts are from the package Ferrite.jl. \n\n\n\n","category":"section"},{"location":"tutorials/tutorial_fem/#Define-hyperelastic-strain-energy-function-(here-neo-Hookean)","page":"tutorial fem","title":"Define hyperelastic strain energy function (here neo-Hookean)","text":"The strain energy function is defined\n\nfunction Ψ(C, C10, D1)\n    J = sqrt(det(C))\n    I1 = tr(C)\n    I1_bar = I1 * J^(-2 / 3)\n    return C10 * (I1_bar - 3) + (1 / D1) * (J - 1)^2\nend\n\n\nSecond Piola–Kirchhoff stress tensor\n\nfunction constitutive_driver(C, C10, D1)\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, C10, D1), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 2.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend\n\n\nAnd for calling the strain energy using C, the first invariant of the Cauchy-Green deformation tensor in the FEM solver\n\nfunction make_constitutive_driver(C10, D1)\n    return C -> constitutive_driver(C, C10, D1)\nend\n\n\nhint: Hint\nIn the following, the FEM parameters are put into the dynamic structure defined above. ","category":"section"},{"location":"tutorials/tutorial_fem/#Problem-and-Load-Type","page":"tutorial fem","title":"Problem and Load Type","text":"Problem and load type are defined\n\nnote: Problem Types\n:plane_strain\n:plane_stress\n:threeD\n\nnote: Load types\n:traction\n:displacement\n\nThis example is :plane_strain  and  :traction.\n\ninput.model_type = :plane_strain   \ninput.load_type = :traction\n","category":"section"},{"location":"tutorials/tutorial_fem/#Define-material-parameters-and-Stress","page":"tutorial fem","title":"Define material parameters and Stress","text":"# E: Young's Modulus\n# ν: Poisson's ratio\n\ninput.E , input.ν = 3.35, 0.45\nE = input.E\nν = input.ν\n\nC10 = E / (4 * (1 + ν))\nD1 = 6.0 * (1.0 - 2.0 * ν) / E\ninput.material = make_constitutive_driver(C10, D1)\n","category":"section"},{"location":"tutorials/tutorial_fem/#Generate-Geometry-and-Mesh","page":"tutorial fem","title":"Generate Geometry and Mesh","text":"Call the mehs function and put into in the dynamic structure.\n\n# Define parameters for the plate and mesh\nLx, Ly = 3.17, 1.73  # Plate dimensions\nnx, ny = 10, 10   # Number of elements along x and y\ngrid = create_grid(Lx, Ly, nx, ny)  # Generate the grid\n","category":"section"},{"location":"tutorials/tutorial_fem/#FEM-Values,-DOF,-Dirichlet-BC","page":"tutorial fem","title":"FEM Values, DOF, Dirichlet BC","text":"Get FEM values, DOF, Dirichlet BC and put them into the dynamic structure.\n\ninput.grid = grid\ninput.dh = create_dofhandler(grid)\ninput.ch = create_bc(input.dh )\n# Create CellValues and FacetValues\ninput.cell_values, input.facet_values = create_values()\n","category":"section"},{"location":"tutorials/tutorial_fem/#Traction-Force","page":"tutorial fem","title":"Traction Force","text":"input.ΓN = getfacetset(grid, \"pressure\")\ninput.facetsets = [input.ΓN]\ninput.traction = [2.2, 0.0]\ninput.tractions = Dict(1 => input.traction)\n","category":"section"},{"location":"tutorials/tutorial_fem/#Dofs-Reaction-Force-and-Displacement","page":"tutorial fem","title":"Dofs Reaction Force & Displacement","text":"To plot force-displacement, Dofs Reaction Force & Displacement are put in the dynamic structure\n\ndof_F_x = input.ch.prescribed_dofs[1:2:end]\ninput.dof_F = dof_F_x;\n\n\ndbc= create_bc_force(input.dh)\ndof_U_x = dbc.prescribed_dofs[1:2:end] \ninput.dof_U = dof_U_x\n\n\nnote: Note\nIf the force-displacement plot is not required, theninput.dof_F = []\ninput.dof_U = []","category":"section"},{"location":"tutorials/tutorial_fem/#Solver-Parameters","page":"tutorial fem","title":"Solver Parameters","text":"The settings for the solver is defined as\n\ninput.tol = 1e-6\nmaxIterPerInc,totalTime,initInc,minInc,maxInc,totalInc = initialize_solver(500,1.0,1e-3,1e-15,0.8,1000)\n\ninput.maxIterPerInc = maxIterPerInc\ninput.totalTime = totalTime\ninput.initInc = initInc\ninput.minInc = minInc\ninput.maxInc = maxInc\ninput.totalInc = totalInc\n\n\nhint: Hint\nThe default value of the solver can also be used asmaxIterPerInc,totalTime,initInc,minInc,maxInc,totalInc = initialize_solver()","category":"section"},{"location":"tutorials/tutorial_fem/#Save-VTU-file","page":"tutorial fem","title":"Save VTU file","text":"The displacement of the last step is saved in the VTU file. Define a name and directory for the file. However, the built-in plot can also be implemented. \n\ninput.filename = \"2D_Hyper\"\ninput.output_dir= \"/Users/aminalibakhshi/Desktop/vtu_geo/\"","category":"section"},{"location":"tutorials/tutorial_fem/#Run-FEM-solver","page":"tutorial fem","title":"Run FEM solver","text":"sol  = run_fem(input)\n\nnote: Note\nThe solver returns a structure with the following fields:# fieldnames(typeof(sol)) ->(:U_steps, :U_effect, :F_effect) \n","category":"section"},{"location":"tutorials/tutorial_fem/#Find-MAX-Displacement","page":"tutorial fem","title":"Find MAX Displacement","text":"U = sol.U_steps[end]\n\n# Extract final displacement and evaluate at grid nodes\nU = sol.U_steps[end]\nu_nodes = vec(evaluate_at_grid_nodes(input.dh, U, :u))\nux, uy = getindex.(u_nodes, 1), getindex.(u_nodes, 2)\n@info \"Max |ux| = $(maximum(abs, ux)), Max |uy| = $(maximum(abs, uy))\"\n\n\n ","category":"section"},{"location":"tutorials/tutorial_fem/#Plot-Displacement-Force","page":"tutorial fem","title":"Plot Displacement Force","text":"GLMakie.closeall()\nfig = Figure(size=(800, 600), fontsize=26)\nax = Axis(fig[1, 1], xlabel=\"Displacement\", ylabel=\"Force\", title=\"force-displacement\", xgridvisible = false, ygridvisible = false)\nlines!((sol.U_effect), abs.(sol.F_effect), color = :black)\nscatter!((sol.U_effect), abs.(sol.F_effect), marker = :circle , color = :red)\ndisplay(fig)\n","category":"section"},{"location":"instruction/#This-is-the-instruction-to-use-the-package","page":"This is the instruction to use the package","title":"This is the instruction to use the package","text":"","category":"section"},{"location":"instruction/#Guid-to-use-Finite-Element(fem)","page":"This is the instruction to use the package","title":"Guid to use Finite Element(fem)","text":"First we need to activate a dynamic structure to have all finite element parameters in it. We do it using \n\ninput = InputStruct()\n\n````\nHere ```input``` is the a structure that will contains all fem parameters. \n\nNow using [Ferrite.jl](https://ferrite-fem.github.io/Ferrite.jl/stable/) we define geometry, mesh, fem parameters for interpolation and numerical integration and define degree-of-freedom. More details for this parts can be found in [Ferrite.jl](https://ferrite-fem.github.io/Ferrite.jl/stable/). \n\nAs an example, we do it for a two dimensional problem.\nOur element here is quad4 and then we define mesh and geometry as\n\n\"\"\" Lx : Lenght in x-direction Ly : Lenght in y-direction Ferrite.Quadrilateral: Define the type of elements. nx : Number of element in x-dir  ny : Number of element in y-dir \"\"\" function creategrid(Lx, Ly, nx, ny)     corners = [         Ferrite.Vec{2}((0.0, 0.0)), Ferrite.Vec{2}((Lx, 0.0)),         Ferrite.Vec{2}((Lx, Ly)), Ferrite.Vec{2}((0.0, Ly))     ]     grid = Ferrite.generategrid(Ferrite.Quadrilateral, (nx, ny), corners)     addnodeset!(grid, \"support_1\", x -> x[1] ≈ 0.0)     addfacetset!(grid, \"pressure\", x -> x[1] ≈ Lx)     return grid end\n\nIt is noted that \n\naddnodeset!(grid, \"support_1\", x -> x[1] ≈ 0.0) addfacetset!(grid, \"pressure\", x -> x[1] ≈ Lx)\n\nare used to define our boundary conditions.\n\nIf you wan to chose other element types like tri3 and so on please refer to [generate_grid](https://github.com/Ferrite-FEM/Ferrite.jl/blob/f1d1d0deef7bdaf019bd63ce9e8d959b6ebc8c4d/src/Grid/grid_generators.jl#L1-L7) .\n\nNext step is defining the fem values (interpolation and numerical integration)\n\n\nfunction createvalues()     dim, order = 2, 1     ip = Ferrite.Lagrange{Ferrite.RefQuadrilateral,order}()^dim     qr = Ferrite.QuadratureRule{Ferrite.RefQuadrilateral}(2)     qrface = Ferrite.FacetQuadratureRule{Ferrite.RefQuadrilateral}(2)     return Ferrite.CellValues(qr, ip), Ferrite.FacetValues(qr_face, ip) end\n\nVery important to know is that the type here should be the same as the element type. For example here we have\n\nFerrite.Quadrilateral and Ferrite.RefQuadrilateral ``` .\n\nThen defining the dof (here is 2D, ux,uy)\n\nfunction create_dofhandler(grid)\n    dh = Ferrite.DofHandler(grid)\n    Ferrite.add!(dh, :u, Ferrite.Lagrange{Ferrite.RefQuadrilateral,1}()^2)\n    Ferrite.close!(dh)\n    return dh\nend\n\n\nNow, we define the Dirichlet boundary condition \n\nfunction create_bc(dh)\n    ch = Ferrite.ConstraintHandler(dh)\n    Ferrite.add!(ch, Ferrite.Dirichlet(:u, Ferrite.getnodeset(dh.grid, \"support_1\"), (x, t) -> [0.0, 0.0], [1, 2]))\n    Ferrite.close!(ch)\n    return ch\nend\n\n\nIf we want to plot force-displacement curve, we need to define another boundary condition to get dof of the displacment for the plot. Displacement where the force is applied. \n\nfunction create_bc_force(dh)\n    dbc = Ferrite.ConstraintHandler(dh)\n    Ferrite.add!(dbc, Ferrite.Dirichlet(:u, getfacetset(grid, \"pressure\"), (x, t) -> 0*x))\n    Ferrite.close!(dbc)\n    return dbc\nend\n\n\nTo now we defined the required functions for fem. These parts are from the package Ferrite.jl. More details can be seen in this package. \n\n\n\nThe hyperelastic strain enenrgy function and stress are now defined. We use the neo-Hookean function, but other strain energy functions can also be employed\n\nfunction Ψ(C, C10, D1)\n    J = sqrt(det(C))\n    I1 = tr(C)\n    I1_bar = I1 * J^(-2 / 3)\n    return C10 * (I1_bar - 3) + (1 / D1) * (J - 1)^2\nend\n\n\nThe second Piola kirchhoff stress and its differentiation are then define \n\nfunction constitutive_driver(C, C10, D1)\n    ∂²Ψ∂C², ∂Ψ∂C = Tensors.hessian(y -> Ψ(y, C10, D1), C, :all)\n    S = 2.0 * ∂Ψ∂C\n    ∂S∂C = 2.0 * ∂²Ψ∂C²\n    return S, ∂S∂C\nend\n\n\nNow, we define a driver for the strain energy in order to inlcude it in the input structure\n\nfunction make_constitutive_driver(C10, D1)\n    return C -> constitutive_driver(C, C10, D1)\nend\n\nWe should tell the solve our problem is 2D or 3D. Also we should define we have applied traction or displacement. Then we should script \n\ninput.model_type = :plane_strain   # or :plane_strain; :plane_stress; :threeD\ninput.load_type = :traction\n\n\nNow we should assign parameters for the materials ans also call the fem function to include them in the input structure.\n\n\ninput.E , input.ν = 3.35, 0.45\nE = input.E\nν = input.ν\nC10 = E / (4 * (1 + ν))\nD1 = 6.0 * (1.0 - 2.0 * ν) / E\ninput.material = make_constitutive_driver(C10, D1)\n\n\nLx, Ly = 3.17, 1.73  # Plate dimensions\nnx, ny = 10, 10   # Number of elements along x and y\ngrid = create_grid(Lx, Ly, nx, ny)  # Generate the grid\n\ninput.grid = grid\ninput.dh = create_dofhandler(grid)\ninput.ch = create_bc(input.dh )\n# Create CellValues and FacetValues\ninput.cell_values, input.facet_values = create_values()\n\n\nApply the traction (it can be multiple tractions)\n\ninput.ΓN = getfacetset(grid, \"pressure\")\ninput.facetsets = [input.ΓN]\ninput.traction = [2.2, 0.0]\ninput.tractions = Dict(1 => input.traction)\n\n\nIf the aim is also plot force-displacement, we shoul also find the dof of reaction force and displacement (if not leave them empty)\n\n\ndof_F_x = input.ch.prescribed_dofs[1:2:end]\ninput.dof_F = dof_F_x;\n\ndbc= create_bc_force(input.dh)\ndof_U_x = dbc.prescribed_dofs[1:2:end] \ninput.dof_U = dof_U_x\n# input.dof_F = []\n# input.dof_U = []\n\n\nDefine the tolernce for solver and also parameters for time integration. Because the problem is nonlinear we need to solve it incrementally (time step here), then\n\ninput.tol = 1e-6\n\n## default\n#maxIterPerInc,totalTime,initInc,minInc,maxInc,totalInc = initialize_solver()\n\n# change like the following if you need\nmaxIterPerInc,totalTime,initInc,minInc,maxInc,totalInc = initialize_solver(500,1.0,1e-3,1e-15,0.8,1000)\n\n\ninput.maxIterPerInc = maxIterPerInc\ninput.totalTime = totalTime\ninput.initInc = initInc\ninput.minInc = minInc\ninput.maxInc = maxInc\ninput.totalInc = totalInc\n\n\nThe solver saves the displacement of the last time step in vtu file for analysis of the results. So solver needs a name and dir to save it \n\ninput.filename = \"2D_Hyper\"\ninput.output_dir= \"/Users/aminalibakhshi/Desktop/vtu_geo/\"\n\n\nHowover, the solver saves the results for each time steps and returns all corresponding displacement vector and use can plot it using Plot.jl or GLMakie.jl\n\nNow, calling the solve\n\nsol  = run_fem(input)\n\n\nSolver is a structure that returns U = sol.U_steps[end] the displacement for each step and sol.F_effect the sum of reaction force and sol.U_effect average displacement in applied force (or displacement).\n\nThe force-displacement can be plotted using GLMakie.jl as\n\nGLMakie.closeall()\nfig = Figure(size=(800, 600))\nax = Axis(fig[1, 1], xlabel=\"Displacement\", ylabel=\"Force\", title=\"force-displacement\", xgridvisible = false, ygridvisible = false)\n\n\n\nlines!((sol.U_effect), abs.(sol.F_effect), color = :black)\nscatter!((sol.U_effect), abs.(sol.F_effect), marker = :circle , color = :red)\ndisplay(fig)\n","category":"section"},{"location":"install/#Install","page":"Install","title":"Install","text":"","category":"section"},{"location":"install/#Installation","page":"Install","title":"Installation","text":"You can install the package using Julia’s package manager:\n\njulia> ]\n\n(@v1.11) pkg> add https://github.com/Aminofa70/FerriteHyperelastic.jl","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#This-tutorial-is-for-curve-fitting-in-hyperelastic-models.","page":"tutorial curve fitting","title":"This tutorial is for curve fitting in hyperelastic models.","text":"hint: Hint\nThe package supports neo-Hookean model\nMooney-Rivlin model\nOgden model\nYeoh models model\n\nnote: Note\nThe package also supports the Drucker stability criterion.\n\nIn order to perform curve fitting, experimental data are required.  Some experimental data are available in HyperData.jl repository. \n\nThe experimental data can be Strain  or  Stretch for x axis and the nominal stress for yaxis.\n\nnote: Steps TODO Curve Fitting\nLoad Package\nRead Experimental Data\nCurve Fitting Inputs\nCall curve fitting function\nCheck the accuracy of the obtained material constant(s).","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#Load-Package","page":"tutorial curve fitting","title":"Load Package","text":"Load the required packages for curve fitting as\n\nusing Revise          # to automatically reload changed code\nusing FerriteHyperelastic\nusing GLMakie\nusing HyperData","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#Read-Experimental-Data","page":"tutorial curve fitting","title":"Read Experimental Data","text":"Read the experimental data as\n\nλ_exp, P_exp = read_data!(Treloar_1944, uniaxial)","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#Curve-Fitting-Inputs","page":"tutorial curve fitting","title":"Curve Fitting Inputs","text":"Set inputs of curve fitting function \n\nwarning: Warning\nThe input MUST be Strain and the Nominal Stress, for this reasion if the data is different  user must convert them to starin and nominal stress\n\n# Input parameters\ninputDataType = \"lambda\"\ndata_type = \"uniaxial\"\nmodelType = \"neo-hookean\"\n\nSexp = P_exp\nstrainExp = λ_exp .- 1\n\n\nnote: Note\nPlease use lowercase letter for all model types (this example is \"neo-hookean\")","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#Call-curve-fitting-function","page":"tutorial curve fitting","title":"Call curve fitting function","text":"The curve-fitting function is now called. For neo-Hookean, the material constant is C1.\n\n# Get material constants by fitting (assumed function)\nmat_cons_solver = solver_constants_hyper(data_type, modelType, strainExp, Sexp)\nC1 = mat_cons_solver[1]\n","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#Check-the-accuracy-of-the-obtained-material-constant(s)","page":"tutorial curve fitting","title":"Check the accuracy of the obtained material constant(s)","text":"# Generate strain values for smooth curve\nϵ = collect(LinRange(strainExp[1], strainExp[end], 100))\n\n# Calculate stretches for incompressible uniaxial tension\nλ1 = @. ϵ + 1\nλ = λ1\nλ2 = @. 1 / sqrt(λ)\nλ3 = λ2   \n\n# neo-Hookean stress (uniaxial nominal stress)\nP_model = @. 2 * C1 * (λ - 1 / λ^2)\n\n# Plot results\nGLMakie.closeall()\n\nfig = Figure(size=(800, 600), fontsize=26)\nax = Axis(fig[1, 1], xlabel= L\"\\mathscr{ε}\", ylabel=L\"P\",  xgridvisible=false, ygridvisible=false)\n\nlines!(ax, ϵ, P_model, color = :black, label=\"Fit, neo-Hookean\")\nscatter!(ax, strainExp, P_exp, marker=:circle, color=:red, label=\"Uniaxial experiment\")\n\naxislegend(ax, position=:lt, backgroundcolor=(:white, 0.7), framecolor=:gray)\ndisplay(fig)\n\n","category":"section"},{"location":"tutorials/tutorial_curve_fitting/#Plain-program","page":"tutorial curve fitting","title":"Plain program","text":"The version of the code without comments.\n\nusing Revise\nusing FerriteHyperelastic\nusing GLMakie\nusing HyperData\n\n\nλ_exp, P_exp = read_data!(Treloar_1944, uniaxial)\n\n\ninputDataType = \"lambda\"\ndata_type = \"uniaxial\"\nmodelType = \"neo-hookean\"\n\nSexp = P_exp\nstrainExp = λ_exp .- 1\n\n\nmat_cons_solver = solver_constants_hyper(data_type, modelType, strainExp, Sexp)\nC1 = mat_cons_solver[1]\n\n\nϵ = collect(LinRange(strainExp[1], strainExp[end], 100))\n\n\nλ1 = @. ϵ + 1\nλ = λ1\nλ2 = @. 1 / sqrt(λ)\nλ3 = λ2   \n\n\nP_model = @. 2 * C1 * (λ - 1 / λ^2)\n\n\nGLMakie.closeall()\n\nfig = Figure(size=(800, 600), fontsize=26)\nax = Axis(fig[1, 1], xlabel= L\"\\mathscr{ε}\", ylabel=L\"P\",  xgridvisible=false, ygridvisible=false)\n\nlines!(ax, ϵ, P_model, color = :black, label=\"Fit, neo-Hookean\")\nscatter!(ax, strainExp, P_exp, marker=:circle, color=:red, label=\"Uniaxial experiment\")\n\naxislegend(ax, position=:lt, backgroundcolor=(:white, 0.7), framecolor=:gray)\ndisplay(fig)","category":"section"},{"location":"#FerriteHyperelastic","page":"Home","title":"FerriteHyperelastic","text":"Welcome to Documentation for FerriteHyperelastic.","category":"section"}]
}
